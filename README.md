# Flan (under active development)
## Fully kinetic Monte Carlo trace impurity following code to be run on top of a turbulent Gkeyll simulation. 

Flan is named after my dog, Flannery. It does not stand for anything. 

<img src="https://github.com/shawnzamperini/flan/blob/main/docs/flan_image.jpg" width="250">

The code can be considered an extension to [Gkeyll](https://gkeyll.readthedocs.io/en/latest/install.html). Typical usage Flan is to track a trace amount of impurities in a turbulent background generated by Gkeyll. Flan track impurities in a plasma in a fully kinetic, Monte Carlo sense and is built on first-principles.

- The particles are tracked according to Lorentz force:
    $$\vec{F}=m(\vec{E} + \vec{v} \times \vec{B})$$
- Particle ionization and recombination is tracked via coupling to ADAS
- (Depreciated, upgrade inbound) Collisions are tracked using the 90-degree collision frequency:
  
    $$\nu_{zi} = \left( \frac{q_z^2 q_i^2 n_i \ln \Lambda}{4 \pi \epsilon_0^2 m_z m_r} \right) \frac{1}{v_{Tz}^3 + 1.3 v_{Ti}^3}$$

    $$ln \Lambda = \ln \left[ \left( \frac{\epsilon_0 T_e}{n_e e^2} \right)^{1/2} \frac{4 \pi \epsilon_0 m_r v_{Tz}^2}{q_z q_i} \right]$$

    $$m_r = \frac{m_z m_i}{m_z + m_i}$$

    Where z = impurity, i = colliding ion (e.g., deuterium).


## Installing Flan

To-do.

## Dependencies

To-do.

## Regression Cases

To-do

## Upcoming Changes

- Rewrite code in C++ to take advantage of parallel architecture (OpenMP + MPI)
- Implement a fully kinetic collision model
- Investigate GPU support to C++ version of code. May become useful in the future.
- Expand code to non-Cartesian geometries
